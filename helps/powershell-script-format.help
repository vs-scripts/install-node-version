|<------------------------------->[ BEGIN-CRFCF ]<------------------------------->|

NOTICE: UNAUTHORIZED MODIFICATION OF THIS DOCUMENT IS EXPRESSLY PROHIBITED. EDITING
PRIVILEGES ARE EXCLUSIVELY RESERVED FOR THE AUTHOR, DESIGNATED CONTRIBUTORS, AND
AUTHORIZED ARTIFICIAL INTELLIGENCE AGENTS. DOCUMENT INTEGRITY IS SECURED BY A
CRYPTOGRAPHIC CHECKSUM; AUTOMATED VERIFICATION SCRIPTS ARE EMPLOYED TO DETECT AND
PREVENT UNAUTHORIZED ALTERATIONS.

0.  METADATA:

    - RFC:      CONCISE-RFC-000000
    - GROUP:    VS-SCRIPTS
    - TITLE:    POWERSHELL SCRIPT FORMAT
    - ACRONYM:  PWSHF
    - AUTHOR:   Richeve Bebedor <richeve.bebedor+vs-scripts@gmail.com>
    - CATEGORY: SPECIFICATION
    - STATUS:   DRAFT
    - VERSION:  000000 (0.0.0)
    - CREATED:  2026-01-18
    - CHECKSUM: <SHA-256>

1.  Summary:

    This document defines the standardized format, conventions, and structure
    for all PowerShell scripts in this repository. All scripts MUST follow
    these patterns to ensure consistency, maintainability, and adherence to
    SOLID principles while remaining concise, helpful, and humane.

2.  Permission:

    NOTICE: PERMISSION TO USE, MODIFY, COPY, AND/OR DISTRIBUTE THIS DOCUMENT
    AND/OR REPOSITORY IS GRANTED UNDER THE TERMS OF THE LICENSE AGREEMENT
    SPECIFIED IN THE LICENSE FILE. PLEASE REFER TO THE LICENSE FILE FOR DETAILS.

3.  Contents:

    0.  METADATA ........................................................... 001
    1.  Summary ............................................................ 015
    2.  Permission ......................................................... 021
    3.  Contents ........................................................... 027
    4.  Document Status .................................................... 035
    5.  Normative Language ................................................. 041
    6.  Naming Conventions ................................................. 049
    7.  Goals and Principles ............................................... 055
    8.  Structure .......................................................... 065
    8.17 Code Region Folding ............................................... 560
    9.  Compliance ......................................................... 450

4.  Document Status:

    - This document is a DRAFT specification for PowerShell script standards.
    - It defines mandatory conventions for all scripts in this repository.
    - It is intended to enforce consistency, clarity, and SOLID principles.

5.  Normative Language:

    - The key words,

        - MUST,
        - MUST NOT,
        - SHOULD,
        - and SHOULD NOT

      in this document SHOULD follow RFC-2119 and RFC-8174.
    - This document MUST NOT use MAY.

6.  Naming Conventions:

    - PowerShell script file names SHOULD use lowercase with hyphens.
    - PowerShell script file names SHOULD be descriptive and concise.
    - Function names MUST use PascalCase with approved PowerShell verbs.
    - Variable names MUST use camelCase with descriptive full names.
    - Boolean variables MUST use prefixes: is, has, should, can.

7.  Goals and Principles:

    - Strictly preserve overall logic and purpose.
    - Follow latest PowerShell standards and conventions.
    - Produce self-documenting code.
    - Eliminate abbreviations, shortened names, and single-character variables.
    - Prevent side effects and scope creep.
    - Respect SOLID principles.
    - Strict adherence to Single Responsibility principle.
    - Avoid unnecessary complexity.
    - Remain concise, helpful, and humane.

8.  Structure:

8.1 Shebang and Batch Fallback Header

    - All scripts MUST include a dual-mode header that allows execution from both
      PowerShell and batch environments:

        <# :
        @echo off
        echo.
        echo Error: This script must be run from a PowerShell terminal.
        echo.
        exit /b 1
        #>

    - Purpose: Prevents accidental execution from cmd.exe with clear error
      messaging.

8.2 Script Metadata

    - Immediately after the header, scripts MUST include comprehensive
      documentation:

        <#
        .SYNOPSIS
            Brief one-line description of what the script does.

        .DESCRIPTION
            Detailed explanation of the script's purpose, what it accomplishes,
            and any important context about its operation.

        .NOTES
            Author: [Author Name]
            Version: 0.0.0
            Last Modified: [Date]
            Platform: Windows only
            Requirements: pwsh 7.5.4+

        .EXAMPLE
            .\script-name.ps1
            Executes the script with default behavior.

        .EXIT CODES
            0 - Success
            1 - Failure (with error message)
        #>

8.3 CmdletBinding and Parameters

    - All scripts MUST declare CmdletBinding:

        [CmdletBinding()]
        param()

    - Scripts accepting arguments MUST use explicit parameters with full names:

        [CmdletBinding()]
        param(
            [Parameter(Mandatory = $true, HelpMessage = "Description")]
            [ValidateNotNullOrEmpty()]
            [string]$ParameterName,

            [Parameter(Mandatory = $false)]
            [switch]$VerboseOutput
        )

8.4 Strict Mode and Error Handling

    - All scripts MUST set strict mode and error preferences:

        Set-StrictMode -Version Latest
        $ErrorActionPreference = 'Stop'

    - Note: These are set in Initialize-ScriptEnvironment function for consistency.

8.5 Function Organization

8.5.1 Function Documentation

    - All functions MUST include comprehensive documentation:

        function Initialize-ScriptEnvironment {
            <#
            .SYNOPSIS
                Initializes PowerShell session preferences.

            .DESCRIPTION
                Sets script-level preferences for Verbose, Debug, ErrorAction,
                and Progress to ensure consistent and informative output
                throughout script execution. These settings apply only to the
                current script scope.

            .NOTES
                This function MUST be called early in script execution, before
                any other operations that depend on these preferences.

            .EXAMPLE
                Initialize-ScriptEnvironment
                Configures all session preferences to their standard values.
            #>
            [CmdletBinding()]
            param()

            $script:VerbosePreference = 'Continue'
            $script:DebugPreference = 'Continue'
            $script:ErrorActionPreference = 'Stop'
            $script:ProgressPreference = 'SilentlyContinue'
        }

8.5.2 Function Parameters

    - All parameters MUST be fully named and documented:

        function Copy-TemplateFile {
            [CmdletBinding()]
            param(
                [Parameter(Mandatory = $true, HelpMessage = "Source file")]
                [ValidateNotNullOrEmpty()]
                [string]$SourceFilePath,

                [Parameter(Mandatory = $true, HelpMessage = "Destination")]
                [ValidateNotNullOrEmpty()]
                [string]$DestinationFilePath
            )

            # Implementation
        }

8.5.3 Function Return Values

    - Functions SHOULD return values explicitly:

        function Get-RepositoryRoot {
            [CmdletBinding()]
            param()

            [string]$repositoryRoot = $PWD.Path

            $gitCommand = Get-Command -Name 'git' -ErrorAction SilentlyContinue
            if ($gitCommand) {
                try {
                    $detectedRoot = (& git rev-parse --show-toplevel 2>$null)
                    if ($detectedRoot -and (Test-Path -LiteralPath $detectedRoot)) {
                        Write-Debug "Detected Git repository root: $detectedRoot"
                        $repositoryRoot = $detectedRoot
                    }
                } catch {
                    Write-Debug "Git root detection failed, using current directory"
                }
            }

            return $repositoryRoot
        }

8.6 Variable Naming Conventions

    - No single-character variables: Use $index not $i, $temporaryValue not $x
    - No abbreviations: Use $repositoryRoot not $repo, $configuration not $config
    - Descriptive names: $isAdministrator not $admin, $windowsCapability not $cap
    - Boolean prefixes: Use $is, $has, $should, $can
    - Scope prefix for script-level: $script:VerbosePreference not
      $VerbosePreference

8.7 Core Functions Required in All Scripts

    - Every script MUST include these foundational functions:

    8.7.1 Initialize-ScriptEnvironment

        - Sets up PowerShell preferences for consistent behavior.

    8.7.2 Assert-WindowsPlatform

        - Validates the script is running on Windows.

    8.7.3 Test-IsInteractivePowerShell

        - Ensures the script runs in an interactive terminal.

    8.7.4 Invoke-PowerShellCoreTransition

        - Relaunches in PowerShell Core (pwsh) if available and version < 7.

    8.7.5 Write-FormattedStep

        - Outputs formatted step messages to console.

    8.7.6 Test-IsAdministrator

        - Checks for administrative privileges (if elevation needed).

    8.7.7 Invoke-ElevationRequest

        - Requests elevation and relaunches the script (if elevation needed).

8.8 Main Execution Flow

    - The main execution section MUST follow this pattern:

        # --- Main Script Execution ---

        Initialize-ScriptEnvironment
        Test-IsInteractivePowerShell

        # Check for elevation if needed
        if ($requiresElevation -and -not (Test-IsAdministrator)) {
            Invoke-ElevationRequest
        }

        Invoke-PowerShellCoreTransition

        try {
            Assert-WindowsPlatform

            # Main script logic here
            Invoke-PrimaryWorkflow

            Write-FormattedStep "Success: Operation completed successfully"
        } catch {
            Write-Error -Message "Operation failed: $($_.Exception.Message)"
            Write-Debug -Message "Stack Trace: $($_.ScriptStackTrace)"
            exit 1
        }

8.9 Error Handling

    - All operations that can fail MUST use try-catch blocks
    - Error messages MUST be meaningful and actionable
    - Debug stack traces MUST be included for troubleshooting
    - Exit with code 1 on failure, 0 on success

        try {
            $result = Invoke-Operation
            Write-Verbose "Operation completed: $result"
        } catch {
            Write-Error -Message "Operation failed: $($_.Exception.Message)"
            Write-Debug -Message "Stack Trace: $($_.ScriptStackTrace)"
            exit 1
        }

8.10 Output and Logging

    - Use Write-Verbose for detailed diagnostic information
    - Use Write-Debug for troubleshooting information
    - Use Write-FormattedStep for major workflow steps
    - Use Write-Warning for non-fatal issues
    - Use Write-Error for fatal issues

        Write-Verbose "Checking for required tool: git"
        Write-Debug "Git command path: $($gitCommand.Source)"
        Write-FormattedStep "Installing required packages"
        Write-Warning "Configuration file not found, using defaults"
        Write-Error "Critical operation failed"

8.11 Path Handling

    - All path operations MUST use -LiteralPath parameter to avoid
    interpretation of special characters:

        if (Test-Path -LiteralPath $filePath) {
            $content = Get-Content -LiteralPath $filePath
            Set-Content -LiteralPath $destinationPath -Value $content
        }

8.12 Command Execution

    - Dynamic command execution MUST use the call operator &:

        $nodeVersion = & node --version
        $gitRoot = & git rev-parse --show-toplevel

8.13 Validation and Assertions

    - Use validation attributes and assertion functions:

        # Parameter validation
        [ValidateNotNullOrEmpty()]
        [ValidateScript({ Test-Path -LiteralPath $_ })]
        [string]$FilePath

        # Assertion functions
        function Assert-CommandExists {
            [CmdletBinding()]
            param(
                [Parameter(Mandatory = $true)]
                [ValidateNotNullOrEmpty()]
                [string]$CommandName
            )

            $command = Get-Command -Name $CommandName -ErrorAction SilentlyContinue
            if (-not $command) {
                throw "Required command not found: $CommandName"
            }
        }

8.14 No Side Effects

    - Functions MUST NOT modify global state unless explicitly documented:

        # BAD: Modifies global environment
        function Set-GlobalPath {
            $env:PATH = "C:\NewPath;$env:PATH"  # Side effect!
        }

        # GOOD: Returns value, caller decides to apply
        function Get-UpdatedPath {
            [CmdletBinding()]
            param(
                [Parameter(Mandatory = $true)]
                [string]$NewPathEntry
            )

            return "$NewPathEntry;$env:PATH"
        }

        # Caller applies the change
        $updatedPath = Get-UpdatedPath -NewPathEntry "C:\NewPath"
        $env:PATH = $updatedPath

8.15 SOLID Principles Application

    8.15.1 Single Responsibility

        - Each function MUST have one clear purpose:

            # Good: Single responsibility
            function Test-IsAdministrator { }
            function Invoke-ElevationRequest { }

            # Bad: Multiple responsibilities
            function CheckAndElevate { }  # Does two things

    8.15.2 Open-Closed

        - Functions MUST be open for extension via parameters, closed for
          modification:

            function Write-FormattedStep {
                [CmdletBinding()]
                param(
                    [Parameter(Mandatory = $true)]
                    [string]$Message,

                    [Parameter(Mandatory = $false)]
                    [ConsoleColor]$ForegroundColor = [ConsoleColor]::Cyan
                )
                # Implementation
            }

    8.15.3 Liskov Substitution

        - Functions MUST follow consistent contracts:

            # All Get-* functions return the same type
            function Get-RepositoryRoot { [string] }
            function Get-ConfigurationPath { [string] }

    8.15.4 Interface Segregation

        - Functions MUST accept only necessary parameters:

            # Good: Only required parameters
            function Initialize-Environment {
                param([string]$RepositoryRoot)
            }

            # Bad: Accepts unnecessary parameters
            function Initialize-Environment {
                param([string]$RepositoryRoot, [string]$Unused1)
            }

    8.15.5 Dependency Inversion

        - Functions MUST depend on abstractions, not concrete implementations:

            # Good: Accepts command name as parameter
            function Invoke-Command {
                param([string]$CommandName)
                & $CommandName
            }

            # Bad: Hardcoded dependency
            function Invoke-Git {
                & git rev-parse --show-toplevel
            }

8.16 Template Structure

    - All scripts SHOULD follow this minimal template structure:

        <# :
        @echo off
        echo.
        echo Error: This script must be run from a PowerShell terminal.
        echo.
        exit /b 1
        #>

        <#
        .SYNOPSIS
            [Brief description]

        .DESCRIPTION
            [Detailed description]

        .NOTES
            Author: [Author]
            Version: 0.0.0
            Platform: Windows only
        #>

        [CmdletBinding()]
        param()

        Set-StrictMode -Version Latest

        # --- Core Functions ---

        function Initialize-ScriptEnvironment {
            # Implementation
        }

        function Assert-WindowsPlatform {
            # Implementation
        }

        function Test-IsInteractivePowerShell {
            # Implementation
        }

        function Invoke-PowerShellCoreTransition {
            # Implementation
        }

        function Write-FormattedStep {
            # Implementation
        }

        # --- Helper Functions ---

        function Test-IsAdministrator {
            # Implementation
        }

        function Invoke-ElevationRequest {
            # Implementation
        }

        # --- Primary Functions ---

        function Invoke-PrimaryWorkflow {
            # Implementation
        }

        # --- Main Script Execution ---

        Initialize-ScriptEnvironment
        Test-IsInteractivePowerShell

        if ($requiresElevation -and -not (Test-IsAdministrator)) {
            Invoke-ElevationRequest
        }

        Invoke-PowerShellCoreTransition

        try {
            Assert-WindowsPlatform
            Invoke-PrimaryWorkflow
            Write-FormattedStep "Success: Operation completed"
        } catch {
            Write-Error "Operation failed: $($_.Exception.Message)"
            Write-Debug "Stack Trace: $($_.ScriptStackTrace)"
            exit 1
        }

8.17 Code Region Folding

    - All scripts SHOULD use #region and #endregion comments to organize code
      into collapsible sections in VS Code.
    - Regions improve readability and navigation in longer scripts.
    - Region names MUST be descriptive and match the section purpose.

    8.17.1 Region Organization Pattern

        #region Core Functions

        function Initialize-ScriptEnvironment {
            # Implementation
        }

        function Assert-WindowsPlatform {
            # Implementation
        }

        #endregion

        #region Helper Functions

        function Test-IsAdministrator {
            # Implementation
        }

        #endregion

        #region Main Script Execution

        Initialize-ScriptEnvironment
        Test-IsInteractivePowerShell

        #endregion

    8.17.2 Nested Regions

        - Regions MAY be nested for deeper organization:

            #region Primary Workflow

            #region Validation

            Assert-WindowsPlatform
            Validate-Prerequisites

            #endregion

            #region Processing

            Invoke-MainOperation

            #endregion

            #endregion

    8.17.3 Region Naming Conventions

        - Region names SHOULD be PascalCase
        - Region names SHOULD be concise but descriptive
        - Region names SHOULD match function grouping or workflow stages

            #region Core Functions
            #region Helper Functions
            #region Main Script Execution
            #region Error Handling
            #region Configuration

    8.17.4 Function-Level Folding

        - Individual functions are automatically foldable in VS Code
        - Function bodies can be collapsed by clicking the chevron next to the
          function declaration
        - No additional markup is required; VS Code recognizes function blocks
          automatically

            function Initialize-ScriptEnvironment {
                <# Function body collapses here #>
            }

            function Assert-WindowsPlatform {
                <# Function body collapses here #>
            }

        - Regions can wrap multiple functions for group-level folding:

            #region Core Functions

            function Initialize-ScriptEnvironment {
                # Implementation
            }

            function Assert-WindowsPlatform {
                # Implementation
            }

            #endregion

        - This allows both individual function folding and group folding

8.18 Common Patterns

    8.18.1 Check and Install Pattern

        function Ensure-ToolInstalled {
            [CmdletBinding()]
            param(
                [Parameter(Mandatory = $true)]
                [string]$ToolName,

                [Parameter(Mandatory = $true)]
                [string]$PackageId
            )

            $toolCommand = Get-Command -Name $ToolName -ErrorAction SilentlyContinue
            if ($toolCommand) {
                Write-Verbose "$ToolName is already installed"
                return
            }

            Write-FormattedStep "$ToolName not found. Installing..."
            Install-PackageWithWinget -PackageId $PackageId
        }

    8.17.2 Validate and Proceed Pattern

        function Validate-Prerequisites {
            [CmdletBinding()]
            param()

            Assert-CommandExists -CommandName 'git'
            Assert-CommandExists -CommandName 'node'
            Assert-WindowsPlatform

            Write-Verbose "All prerequisites validated"
        }

    8.17.3 Configuration with Defaults Pattern

        function Get-Configuration {
            [CmdletBinding()]
            param(
                [Parameter(Mandatory = $false)]
                [string]$ConfigurationPath = (Join-Path $env:APPDATA 'MyApp\config.json')
            )

            if (Test-Path -LiteralPath $ConfigurationPath) {
                return Get-Content -LiteralPath $ConfigurationPath | ConvertFrom-Json
            }

            Write-Verbose "Configuration file not found, using defaults"
            return @{ DefaultSetting = $true }
        }

9.  Compliance:

    - All scripts MUST read this PWSHF document.
    - All scripts MUST follow this PWSHF document.
    - All scripts MUST NOT edit this PWSHF document.
    - All AI agents MUST read this PWSHF document.
    - All AI agents MUST add this PWSHF document to their context.
    - All AI agents MUST follow this PWSHF document.
    - All AI agents MUST NOT edit this PWSHF document.
    - All scripts MUST adhere to the normative language requirements.
    - All scripts MUST respect the 5LAWS.

9.1 Review Checklist

    - [ ] Shebang and batch fallback header present
    - [ ] Script metadata with SYNOPSIS, DESCRIPTION, NOTES
    - [ ] CmdletBinding and parameters defined
    - [ ] All functions have full documentation
    - [ ] No abbreviations or single-character variables
    - [ ] No side effects outside function scope
    - [ ] Proper error handling with try-catch
    - [ ] Consistent use of Write-Verbose, Write-Debug, Write-FormattedStep
    - [ ] Path handling uses -LiteralPath
    - [ ] Command execution uses & operator
    - [ ] SOLID principles applied
    - [ ] Main execution flow follows standard pattern
    - [ ] Exit codes: 0 for success, 1 for failure
    - [ ] Code organized with #region and #endregion for folding

9.2 References

    - PowerShell Scripting Best Practices
      https://learn.microsoft.com/en-us/powershell/scripting/learn/ps101/09-functions

    - Approved PowerShell Verbs
      https://learn.microsoft.com/en-us/powershell/scripting/developer/cmdlet/approved-verbs-for-powershell-commands

    - SOLID Principles
      https://en.wikipedia.org/wiki/SOLID

    - PowerShell Style Guide
      https://poshcode.gitbook.io/powershell-practice-and-style/

    - RFC 2119 - Key words for use in RFCs
      https://tools.ietf.org/html/rfc2119

    - RFC 8174 - Ambiguity of Uppercase vs Lowercase in RFC 2119
      https://tools.ietf.org/html/rfc8174

|<------------------------------->[ ENDED-CRFCF ]<------------------------------->|

