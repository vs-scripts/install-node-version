AI COMMIT & PUSH PROTOCOL

This protocol is mandatory and overrides default agent behavior.

PHASE 0 — AUTHORITY & PRECONDITIONS

1. Read and comply with ./5LAWS.
2. Read and comply with ./RULES.
3. Read and comply with ./FORMAT.
4. Read and comply with ./helps/concise-commit-format.help.
5. Read and understand ./helps/commit-prompt-flow.help for protocol guidance.
6. Rules apply in the order listed above.
7. Commit message rules in ./helps/concise-commit-format.help override ./FORMAT.
8. If any rule is ambiguous or conflicting, stop and request clarification.
   Do not make assumptions.

PHASE 1 — STATE INSPECTION

9. List repository changes relative to HEAD:
   - modified files
   - added (untracked) files
   - deleted files
10. Output this list before creating any commit.

PHASE 2 — COMMIT PLANNING

11. Create a commit plan using only the files listed in Phase 1.
12. Follow ./RULES, including one file per commit.
13. Do not batch unrelated changes.
14. Define commit messages using concise-commit-format.help.
15. Output the commit plan before execution.

PHASE 3 — EXECUTION

16. Create commits exactly as defined in the commit plan.
17. Each commit must modify only one file.
18. Each commit message must follow concise-commit-format.help.
19. If any commit violates rules or format, stop and report the issue.

PHASE 4 — VERIFICATION

20. After each commit, verify:
    - the correct file was committed
    - the commit scope matches the plan
    - the commit body has exactly 5 numbered lines
    - each line is 83 characters or fewer
21. If verification fails, do not push and report the failure.

PHASE 5 — PUSH & TERMINATION

22. Push commits only after all commits pass verification.
23. Check repository status after pushing.
24. If no uncommitted changes remain, stop.
25. If changes remain, restart from Phase 1.
